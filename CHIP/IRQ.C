/*-----------------------------------------------------------------------------
 * MODULE IRQ.C
 *
 * Copyright(c) 1996-2010, Insyde Software Corporation. All Rights Reserved.
 *
 * You may not reproduce, distribute, publish, display, perform, modify, adapt,
 * transmit, broadcast, present, recite, release, license or otherwise exploit
 * any part of this publication in any form, by any means, without the prior
 * written permission of Insyde Software Corporation.
 *
 *-----------------------------------------------------------------------------
 *
 * Contains interrupt handlers.  These handlers are called by the actual
 * interrupt service routines.  The details of handling the hardware is done by
 * the interrupt service routine in the OEM layer, not by these handlers.
 * If more control is needed for a certain implementation, this file can be
 * moved to the MOD directory of the OEM layer.
 *
 * Revision History (Started May 15, 1995 by GLP)
 *
 * GLP
 * 20 Nov 96   Added support for I2C bus (ACCESS.bus).
 * 22 Jan 97   Changed Irq_Anykey() to check for all the keys
 *             being released before disabling the Any Key
 *             Wakeup feature.  The check for all the keys
 *             being released was being done after the feature
 *             was disabled so the check was not working.
 * 27 Feb 98   Removed references to EMUL.
 * 11 Mar 98   Changed Irq_Timer_A for I2C_SUPPORTED routine.
 * 19 Mar 98   Moved the handling of the 10 mS timer and the I2C
 *             service from the Irq_Timer_A routine a 1 mS service
 *             routine in main.
 * 17 Apr 98   Removed the Aux_Portx.inh flag.
 * 21 Aug 98   Removed Stop_Timer_A() and Load_Timer_A() calls
 *             from Irq_Timer_A and added ICU_Clr_Pending_Irq
 *             call to make the 1 mS timer more accurate.
 * 02 Sep 98   Removed Signal_Timer from Irq_Timer_A.
 * 28 Sep 98   Removed Irq_Ext and Irq_Nmi.
 * 19 Aug 99   Updated copyright.
 * 02 Sep 99   Added countdown for HIF2_SAFETY in Irq_Timer_A().
 * 20 Jan 00   Support to disable internal mouse if external mouse
 *             exists is marked as V21.3.
 * EDH
 * 11 Dec 00 	Support the fourth PS/2 port as port 4. It will be
 *             recognized as port 0 with Active PS/2 Multiplexing
 *	            driver.
 * 18 Jan 01   Allow OEM enable/disable PS/2 port4 support in OEMBLD.MAK.
 * 25 Jan 05   Removed switch for PS/2 Port4 supported.
 *             Added a switch for OEM to enable/disable PS/2 Port2 supported.
 * 15 Feb 05   Added to process command/data write from Third Host Interface.
 * ------------------------------------------------------------------------- */

#define IRQ_C

#include "swtchs.h"
#include "host_if.h"
#include "purscn.h"
#include "proc.h"
#include "irq.h"
#include "ps2.h"
#include "chiphook.h"
#include "timers.h"
#include "purdat.h"
#include "scan.h"
#include "i2c.h"
#include "purdev.h"
#include "staticfg.h"
#include "com_defs.h"
#include "port80.h"


#ifndef AUX_PORT3_SUPPORTED
#error AUX_PORT3_SUPPORTED switch is not defined.
#endif

#ifndef AUX_PORT2_SUPPORTED
#error AUX_PORT2_SUPPORTED switch is not defined.
#endif

#ifndef I2C_SUPPORTED
#error I2C_SUPPORTED switch is not defined.
#endif

static void Irq_Aux_Proc(void);
extern void Handle_SMBus(void);

/* ---------------------------------------------------------------
   Name: Irq_Aux_Port1

   This is traditionally the auxiliary keyboard clock interrupt.

   Handle IRQ generated by hardware shift mechanism.

                     OR

   Handle IRQ generated by auxiliary device via clock line.
   Either the auxiliary device is clocking in data that is being
   sent to it, or it is clocking out data that it is sending.
   This handler will send/receive 1 bit of data, and then return.

   IMPORTANT: The minimum clock pulse inactive (low) time is 30us,
   and the minimum clock pulse active (high) time is also 30us (as
   defined in the IBM AT keyboard technical reference manual).
   This means that processing in the handler must be finished
   within about 55 us (before the next inactive clock level
   arrives) so the next high to low transition of the clock will
   generate another IRQ so the next bit can be sent/received.
   The critical bit is the first bit (particularly when receiving
   data), because some "setup" work has to be done when this bit
   is received.  WE CANNOT SPEND TOO MUCH TIME IN THE IRQ HANDLER
   WHEN THE FIRST BIT IS RECEIVED OR A BIT WILL BE MISSED!  The AUX
   IRQ has a very high priority so there should be no problem with
   other IRQs interrupting while a bit is being sent/received.

   Returns: On return the variables Aux_Port1, Aux_Data.byte,
            and Aux_Status are updated with new values as
            a result of the bit send/receive.
   Specials: All registers that are used
             must be preserved for IRQ handlers!
   --------------------------------------------------------------- */
void Irq_Aux_Port1(void)
{
   if (Int_Var.Low_Power_Mode)
   {
      /* Recovering from low power mode.

         This must be a valid wakeup interrupt because
         only valid wakeup interrupts are enabled.  */

      Int_Var.Low_Power_Mode = 0;/* Clear Low_Power_Mode flag to
                                    notify IDLE loop of recovery. */
   }
   else
   {
      /* Code for handling auxiliary device
         using hardware shift mechanism. */

      /* Control has been transferred to this point because of
         a Start of Transaction or End of Transaction interrupt. */

      Int_Lock_Alt_Aux1();

      Int_Var.Active_Aux_Port = AUX_PORT1_CODE;

      if (IS_BIT_SET(PSTAT, PSTAT_EOT))
      {
         /* End of Transaction. */

         if (Aux_Status.Send_Flag)
         {
            /* End of sending data to auxiliary device. */

            Int_Lock_Aux_Port1();

            /* Start inhibit delay timer. */
            Load_Timer_B();
            Timer_B.bit.INH_CLEAR = 1;

            Disable_Gentmo();
            Aux_Status.Send_Flag = 0;       /* Indicate send complete. */
            CLEAR_BIT(PSCON, PSCON_XMT);    /* Setup hardware for receive. */
         }
         else
         {
            /* End of receiving data from auxiliary device. */

            Int_Lock_Aux_Port1();   /* Prevent any new transmissions
                                       from this auxiliary device
                                       until the data byte is handled. */

            Irq_Aux_Proc();
            /* Start inhibit delay timer. */
            Load_Timer_B();
            Timer_B.bit.INH_CLEAR = 1;

            Disable_Gentmo();

            Aux_Data.byte = PSDAT;

            /* Use Aux_Status.Parity_Flag as a parity
               error flag instead of as a parity bit. */
            if (IS_BIT_SET(PSTAT, PSTAT_PERR))
            {
                Aux_Status.Parity_Flag = 1;
            }
            else
            {
                Aux_Status.Parity_Flag = 0;
            }

            /* Int_Var.Active_Aux_Port has port number. */
            Service.bit.AUX_PORT_SND = 1; /* Post service request. */
         }
      }
      else
      {
         /* Assume that it is a Start of Transaction. */

         /* Mask Start of Transaction (SOT) interrupt to allow
            the End of Transaction interrupt to be recognized
            by the interrupt mechanism.  (The SOT signal does
            not clear while transfer is taking place.) */
         CLEAR_BIT(PSIEN, PSIEN_SOTIE);

         if (Aux_Status.Send_Flag)
         {
            /* Start of sending data to auxiliary device. */
            Enable_Gentmo(TRANSMIT_TMO);
         }
         else
         {
            /* Start of receiving data from auxiliary device. */

            Enable_Gentmo(RECEIVE_TMO);

            /* The following is usually done after the data bits have
               been received.  Since the hardware will generate an
               interrupt after the stop bit, this will be done now. */
            Irq_Aux_Proc();

         }
      }
   }
}

#if AUX_PORT2_SUPPORTED
/* ---------------------------------------------------------------
   Name: Irq_Aux_Port2

   This is traditionally the auxiliary mouse clock interrupt.

   Handle IRQ generated by hardware shift mechanism.

                     OR

   Handle IRQ generated by auxiliary device via clock line.
   Either the auxiliary device is clocking in data that is being
   sent to it, or it is clocking out data that it is sending.
   This handler will send/receive 1 bit of data, and then return.

   IMPORTANT: The minimum clock pulse inactive (low) time is 30us,
   and the minimum clock pulse active (high) time is also 30us (as
   defined in the IBM AT keyboard technical reference manual).
   This means that processing in the handler must be finished
   within about 55 us (before the next inactive clock level
   arrives) so the next high to low transition of the clock will
   generate another IRQ so the next bit can be sent/received.
   The critical bit is the first bit (particularly when receiving
   data), because some "setup" work has to be done when this bit
   is received.  WE CANNOT SPEND TOO MUCH TIME IN THE IRQ HANDLER
   WHEN THE FIRST BIT IS RECEIVED OR A BIT WILL BE MISSED!  The AUX
   IRQ has very high priority so there should be no problem with
   other IRQs interrupting while a bit is being sent/received.

   Returns: On return the variables Aux_Port2, Aux_Data.byte,
            and Aux_Status are updated with new values as
            a result of the bit send/receive.
   Specials: All registers that are used
             must be preserved for IRQ handlers!
   --------------------------------------------------------------- */
void Irq_Aux_Port2(void)
{
   if (Int_Var.Low_Power_Mode)
   {
      /* Recovering from low power mode. */

      /* This is a valid wakeup interrupt.

         This must be a valid wakeup interrupt because
         only valid wakeup interrupts are enabled.  */

      Int_Var.Low_Power_Mode = 0;/* Clear Low_Power_Mode flag to
                                    notify IDLE loop of recovery. */
   }
   else
   {
      /* Code for handling auxiliary device
         using hardware shift mechanism. */

      /* Control has been transferred to this point because of
         a Start of Transaction or End of Transaction interrupt. */

      Int_Lock_Alt_Aux2();
      Int_Var.Active_Aux_Port = AUX_PORT2_CODE;

      if (IS_BIT_SET(PSTAT, PSTAT_EOT))
      {
         /* End of Transaction. */

         if (Aux_Status.Send_Flag)
         {
            /* End of sending data to auxiliary device. */

            Int_Lock_Aux_Port2();

            /* Start inhibit delay timer. */
            Load_Timer_B();
            Timer_B.bit.INH_CLEAR = 1;

            Disable_Gentmo();
            Aux_Status.Send_Flag = 0;       /* Indicate send complete. */
            CLEAR_BIT(PSCON, PSCON_XMT);    /* Setup hardware for receive. */
         }
         else
         {
            /* End of receiving data from auxiliary device. */

            Int_Lock_Aux_Port2();   /* Prevent any new transmissions
                                       from this auxiliary device
                                       until the data byte is handled. */

            Irq_Aux_Proc();
            /* Start inhibit delay timer. */
            Load_Timer_B();
            Timer_B.bit.INH_CLEAR = 1;

            Disable_Gentmo();

            Aux_Data.byte = PSDAT;

            /* Use Aux_Status.Parity_Flag as a parity
               error flag instead of as a parity bit. */
            if (IS_BIT_SET(PSTAT, PSTAT_PERR))
            {
                Aux_Status.Parity_Flag = 1;
            }
            else
            {
                Aux_Status.Parity_Flag = 0;
            }

            /* Int_Var.Active_Aux_Port has port number. */
            Service.bit.AUX_PORT_SND = 1; /* Post service request. */
         }
      }
      else
      {
         /* Assume that it is a Start of Transaction. */

         /* Mask Start of Transaction (SOT) interrupt to allow
            the End of Transaction interrupt to be recognized
            by the interrupt mechanism.  (The SOT signal does
            not clear while transfer is taking place.) */
         CLEAR_BIT(PSIEN, PSIEN_SOTIE);

         if (Aux_Status.Send_Flag)
         {
            /* Start of sending data to auxiliary device. */
            Enable_Gentmo(TRANSMIT_TMO);
         }
         else
         {
            /* Start of receiving data from auxiliary device. */

            Enable_Gentmo(RECEIVE_TMO);

            /* The following is usually done after the data bits have
               been received.  Since the hardware will generate an
               interrupt after the stop bit, this will be done now. */
            Irq_Aux_Proc();
         }
      }
   }
}
#endif

#if AUX_PORT3_SUPPORTED
/* ---------------------------------------------------------------
   Name: Irq_Aux_Port3

   This is normally the internal pointing device clock interrupt.
   If used, this device is always present.

   Handle IRQ generated by hardware shift mechanism.

                     OR

   Handle IRQ generated by auxiliary device via clock line.
   Either the auxiliary device is clocking in data that is being
   sent to it, or it is clocking out data that it is sending.
   This handler will send/receive 1 bit of data, and then return.

   IMPORTANT: The minimum clock pulse inactive (low) time is 30us,
   and the minimum clock pulse active (high) time is also 30us (as
   defined in the IBM AT keyboard technical reference manual).
   This means that processing in the handler must be finished
   within about 55 us (before the next inactive clock level
   arrives) so the next high to low transition of the clock will
   generate another IRQ so the next bit can be sent/received.
   The critical bit is the first bit (particularly when receiving
   data), because some "setup" work has to be done when this bit
   is received.  WE CANNOT SPEND TOO MUCH TIME IN THE IRQ HANDLER
   WHEN THE FIRST BIT IS RECEIVED OR A BIT WILL BE MISSED!  The AUX
   IRQ has very high priority so there should be no problem with
   other IRQs interrupting while a bit is being sent/received.

   Returns: On return the variables Aux_Port3, Aux_Data.byte,
            and Aux_Status are updated with new values as
            a result of the bit send/receive.
   Specials: All registers that are used
             must be preserved for IRQ handlers!
   --------------------------------------------------------------- */
void Irq_Aux_Port3(void)
{
   if (Int_Var.Low_Power_Mode)
   {
      /* Recovering from low power mode. */

      /* This is a valid wakeup interrupt.

         This must be a valid wakeup interrupt because
         only valid wakeup interrupts are enabled.  */

      Int_Var.Low_Power_Mode = 0;/* Clear Low_Power_Mode flag to
                                    notify IDLE loop of recovery. */
   }
   else
   {
      /* Code for handling auxiliary device
         using hardware shift mechanism. */

      /* Control has been transferred to this point because of
         a Start of Transaction or End of Transaction interrupt. */

      Int_Lock_Alt_Aux3();
      Int_Var.Active_Aux_Port = AUX_PORT3_CODE;

      if (IS_BIT_SET(PSTAT, PSTAT_EOT))
      {
         /* End of Transaction. */

         if (Aux_Status.Send_Flag)
         {
            /* End of sending data to auxiliary device. */

            Int_Lock_Aux_Port3();

            /* Start inhibit delay timer. */
            Load_Timer_B();
            Timer_B.bit.INH_CLEAR = 1;

            Disable_Gentmo();
            Aux_Status.Send_Flag = 0;       /* Indicate send complete. */
            CLEAR_BIT(PSCON, PSCON_XMT);    /* Setup hardware for receive. */
         }
         else
         {
            /* End of receiving data from auxiliary device. */

            Int_Lock_Aux_Port3();   /* Prevent any new transmissions
                                       from this auxiliary device
                                       until the data byte is handled. */

            Irq_Aux_Proc();
            /* Start inhibit delay timer. */
            Load_Timer_B();
            Timer_B.bit.INH_CLEAR = 1;

            Disable_Gentmo();

            Aux_Data.byte = PSDAT;

            /* Use Aux_Status.Parity_Flag as a parity
               error flag instead of as a parity bit. */
            if (IS_BIT_SET(PSTAT, PSTAT_PERR))
            {
                Aux_Status.Parity_Flag = 1;
            }
            else
            {
                Aux_Status.Parity_Flag = 0;
            }

            /* Int_Var.Active_Aux_Port has port number. */
            Service.bit.AUX_PORT_SND = 1; /* Post service request. */
         }
      }
      else
      {
         /* Assume that it is a Start of Transaction. */

         /* Mask Start of Transaction (SOT) interrupt to allow
            the End of Transaction interrupt to be recognized
            by the interrupt mechanism.  (The SOT signal does
            not clear while transfer is taking place.) */
         CLEAR_BIT(PSIEN, PSIEN_SOTIE);

         if (Aux_Status.Send_Flag)
         {
            /* Start of sending data to auxiliary device. */
            Enable_Gentmo(TRANSMIT_TMO);
         }
         else
         {
            /* Start of receiving data from auxiliary device. */

            Enable_Gentmo(RECEIVE_TMO);

            /* The following is usually done after the data bits have
               been received.  Since the hardware will generate an
               interrupt after the stop bit, this will be done now. */
            Irq_Aux_Proc();
         }
      }
   }
}
#endif

static void Irq_Aux_Proc(void)
{
    Int_Lock_Scan();

            /* The following is usually done after the data bits have
               been received.  Since the hardware will generate an
               interrupt after the stop bit, this will be done now. */
    Disable_Host_IBF_Irq();    /* Disable PC interface interrupt. */
}


/* ---------------------------------------------------------------
   Name: Irq_Ibf1

   Primary interface input buffer full interrupt handler.
   Generated when the primary interface input buffer is written
   to by the Host and the input buffer full bit is enabled.

   Returns: On return the service bit is set.
   Specials: All registers that are used
             must be preserved for IRQ handlers!
   --------------------------------------------------------------- */
void Irq_Ibf1(void)
{
   Disable_Host_IBF_Irq(); /* Disable PC interface interrupt. */

   if (Input_Buffer_Full() == 0)
   {
      /* At this point, the IBF bit is not actually set. */
      Enable_Host_IBF_Irq();  /* Re-enable interrupt and exit. */
   }
   else
   {
      Disable_Host_OBE1_Irq(); /* New command issued and disable OBE irq. */
      Lock_Aux_Devs();  /* Prevent auxiliary device transmissions. */
      Lock_Scan();
      Disable_Gentmo();

      /* Clear pending unlock requests. */
      Timer_B.bit.UNLOCK_TMO = 0;
      Service.bit.UNLOCK = 0;
      /* Service Host interface through main loop. */
      Service.bit.PCI = 1;
   }
}

/* ---------------------------------------------------------------
   Name: Irq_Ibf2

   Secondary interface input buffer full interrupt handler.
   Generated when the secondary interface input buffer is written
   to by the Host and the input buffer full bit is enabled.

   Returns: On return the service bit is set.
   Specials: All registers that are used
             must be preserved for IRQ handlers!
   --------------------------------------------------------------- */
void Irq_Ibf2(void)
{
   //Disable_Host_IBF2_Irq(); /* Disable secondary PC interface interrupt. */
   //Disable_Host_IBF3_Irq(); /* Disable third PC interface interrupt. */
   //Disable_Host_IBF4_Irq();
   //Disable_Host_IBF5_Irq();

    // check PM1
    if (Read_Host_IBF2_Irq())
    {   /* At this point, the secondary host interrupt is enabled. */
        if (Input_Buffer2_Full())
        {
            /* Service Secondary Host interface - PM1 - through main loop. */
            Service.bit.PCI2 = 1;
            Disable_Host_IBF2_Irq(); /* Disable secondary PC interface interrupt. */
        }
    }

    // check PM2
    if (Read_Host_IBF3_Irq())
    {   /* At this point, the third host interrupt is enabled. */
        if (Input_Buffer3_Full())
        {
            /* Service Secondary Host interface - PM2 - through main loop. */
            Service.bit.PCI3 = 1;
            Disable_Host_IBF3_Irq(); /* Disable third PC interface interrupt. */
        }
    }

    // check PM3
    if (Read_Host_IBF4_Irq())
    {   /* At this point, the fourth host interrupt is enabled. */
        if (Input_Buffer4_Full())
        {
            /* Service Secondary Host interface - PM3 - through main loop. */
            Disable_Host_IBF4_Irq(); /* Disable third PC interface interrupt. */
        }
    }

    // check PM4
    if (Read_Host_IBF5_Irq())
    {   /* At this point, the fifth host interrupt is enabled. */
        if (Input_Buffer5_Full())
        {
            /* Service Secondary Host interface - PM4 - through main loop. */
            Disable_Host_IBF5_Irq(); /* Disable third PC interface interrupt. */
        }
    }
}

/* ---------------------------------------------------------------
   Name: Irq_Timer_A

   Handle Timer A interrupts.  Timer A has a time base of 1 mS.

   Input: On entry, "TIMER Timer_A" has
          the event (or events) to handle.
      Valid Events:
         TMR_SCAN -
         TMR_GENTMO - This timer is a timer that is used for
            timeout detection of serial data transmissions
            to/from the auxiliary keyboard/pointing devices.

   Specials: All registers that are used
             must be preserved for IRQ handlers!
   --------------------------------------------------------------- */
extern BYTE ACPI_Timer;

void Irq_Timer_A(void)
{
    #if DEEP_IDLE_S0
    if (!Timer_A.bit.TMR_SCAN && !Timer_A.bit.TMR_GENTMO && (ACPI_Timer == 0)
        /* && (funct.smi_timer == 0) */ && (Aux_Port1.sequence == IDLE)
        && (I2c_Var[0].I2c_Irq_State == 1) && (I2c_Var[1].I2c_Irq_State == 1) &&
        Gen_Hookc_Timer_A_Check() && (DIDLE_Delay == 0) && (Service.word == 0))
    {
        Stop_Timer_A();
    }
    #endif

    if (DIDLE_Delay)
    {
        DIDLE_Delay--;
    }
    #if KERNEL_TICKER_T0
    ICU_Clr_Pending_Irq(ICU_EINT_T0OUT);   /* Clear the interrupt. */
    SET_BIT(WKPCL2, MASK(bit7));
    #endif //KERNEL_TICKER_T0

    Gen_Hookc_Irq_Timer_A();
	//Load_Timer_A();

    Service.bit.MS_1 = 1;   /* Request 1 mS timer service. */
    #if I2C_SUPPORTED
    Handle_SMBus();
    #endif

    if (Timer_A.byte)
    {
        /* Count down HIF2_SAFETY.  Actually, it is larger than one bit. */
        if (Timer_A.bit.HIF2_SAFETY) Timer_A.bit.HIF2_SAFETY--;

        if (Timer_A.bit.TMR_SCAN)
        {
                Service.bit.KEY = 1; /* Request scanner service. */
            }
        #if TICKER_1MS
        if (Timer_A.bit.TMR_GENTMO)
        {
            Gen_Timer--;

            if (Gen_Timer == 0)
            {   /*
                A timeout occurred when communicating to
                an auxiliary device or when a response is
                expected and the device did not respond.

                If the start bit was sent or received,
                Int_Var.Active_Aux_Port contains the port
                number of the device that was clocking.

                If the error occurred for a transmission to
                a device and the start bit was not sent,
                Int_Var.Active_Aux_Port contains the port
                number for the device that was to receive the data.

                If the error occurred when a response was expected
                and no device responded, Int_Var.Active_Aux_Port
                contains the port number of the expected response.
                In this case, all devices may be unlocked. */

                Timer_A.bit.TMR_GENTMO = 0;
                Gen_Timer = (BYTE) ~0;     /* Indicate timeout occured. */

                Service.bit.AUX_PORT_SND = 1; /* Post service request to
                                                 send error code to Host. */
                Disable_Host_IBF_Irq();    /* Disable PC interface interrupt. */

                if (Aux_Port1.lock == 0)
                {
                    /* Device on auxiliary port 1 is not locked out. */
                    Int_Lock_Aux_Port1();
                    Set_Aux_Port1_Dat();       /* Reset data transmission line. */
                }

                #if AUX_PORT2_SUPPORTED
                if (Aux_Port2.lock == 0)
                {
                    /* Device on auxiliary port 2 is not locked out. */
                    Int_Lock_Aux_Port2();
                    Set_Aux_Port2_Dat();       /* Reset data transmission line. */
                }
                #endif

                #if AUX_PORT3_SUPPORTED
                if (Aux_Port3.lock == 0)
                {
                    /* Device on auxiliary port 3 is not locked out. */
                    Int_Lock_Aux_Port3();
                    Set_Aux_Port3_Dat();       /* Reset data transmission line. */
                }
                #endif

                /*
                Assume that at least one device was not
                locked out and start inhibit delay timer. */

                Load_Timer_B();
                Timer_B.bit.INH_CLEAR = 1;
            }
        }
        #endif // TICKER_1MS
    }
    /* Count down HIF3_SAFETY.  Actually, it is larger than one bit. */
    if (Timer_A3.byte)
    {
        Timer_A3.bit.HIF3_SAFETY--;
    }
    /* Count down HIF4_SAFETY.  Actually, it is larger than one bit. */
    if (Timer_A4.byte)
    {
        Timer_A4.bit.HIF4_SAFETY--;
    }
    /* Count down HIF5_SAFETY.  Actually, it is larger than one bit. */
    if (Timer_A5.byte)
    {
        Timer_A5.bit.HIF5_SAFETY--;
    }
}

/* ---------------------------------------------------------------
   Name: Irq_Timer_B

   Handle Timer B interrupts.  Timer B has a time base of 150 uS.

   Inputs: On entry, "TIMER Timer_B" has
           the event (or events) to handle.
      Valid Events:
         SEND_ENABLE - When the timer count associated with
            this event expires, post a send request to send local
            keyboard data to Host, or to send data from multiple
            byte command response to Host.
         INH_CLEAR - Delay timer to give auxiliary devices time to
            recognize their clock line is inhibited (clock forced low).
         UNLOCK_TMO - When this event occurs, post an unlock
            service request so auxiliary devices can transmit/receive
            data again.

   Specials: All registers that are used
             must be preserved for IRQ handlers!
   --------------------------------------------------------------- */
void Irq_Timer_B(void)
{
   Stop_Timer_B();

   Timer_B.bit.INH_CLEAR = 0; /* Always clear inhibit. */
   if (Timer_B.bit.UNLOCK_TMO)
   {
      /* Delay for unlock request. */
      Timer_B.bit.UNLOCK_TMO = 0;
      Service.bit.UNLOCK = 1;       /* Request unlock service. */

      Timer_B.bit.SEND_ENABLE = 0;
   }
   #if MOUSE_EMULATION
   else if ( Timer_B.bit.SEND_ENABLE && ((Int_Var.Scan_Lock == 0) || Aux_Tmp_Load1))
   #else // MOUSE_EMULATION
   else if ( Timer_B.bit.SEND_ENABLE && (Int_Var.Scan_Lock == 0) )
   #endif // MOUSE_EMULATION
   {
      /* Scanner send request and scanner is not disabled. */

      /* SEND_DELAY is, actually, more than one bit. */
      Timer_B.bit.SEND_DELAY--;
      if (Timer_B.bit.SEND_DELAY == 0)
      {
         Service.bit.SEND = 1;      /* Post service request. */
         Int_Var.Scan_Lock = 1;     /* Lock scanner transmission. */
         Timer_B.bit.SEND_ENABLE = 0;
      }
      else
      {
         if (Timer_B.bit.SEND_DELAY == 2)
         {
            Disable_Host_IBF_Irq(); /* Disable PC interface interrupt. */
         }
         /* At this point,
               Timer_B.bit.INH_CLEAR = 0,
               Timer_B.bit.UNLOCK_TMO = 0,
               Timer_B.bit.SEND_ENABLE = 1,
               Timer_B.bit.SEND_DELAY has updated count. */

         Load_Timer_B();
      }
   }
   else
   {
      Timer_B.bit.SEND_ENABLE = 0;
   }
}

#if !TICKER_1MS
/* ---------------------------------------------------------------
   Name: Irq_Timer_PS2

   Handle Timer PS2 interrupts.

   Inputs: On entry, "TIMER Timer_PS2" has
           the event (or events) to handle.
   Return: None
   --------------------------------------------------------------- */
void Irq_Timer_PS2(void)
{ /*
    A timeout occurred when communicating to
    an auxiliary device or when a response is
    expected and the device did not respond.

    If the start bit was sent or received,
    Int_Var.Active_Aux_Port contains the port
    number of the device that was clocking.

    If the error occurred for a transmission to
    a device and the start bit was not sent,
    Int_Var.Active_Aux_Port contains the port
    number for the device that was to receive the data.

    If the error occurred when a response was expected
    and no device responded, Int_Var.Active_Aux_Port
    contains the port number of the expected response.
    In this case, all devices may be unlocked. */


    Service.bit.AUX_PORT_SND = 1; /* Post service request to
                                     send error code to Host. */
    Disable_Host_IBF_Irq();    /* Disable PC interface interrupt. */

    if (Aux_Port1.lock == 0)
    {
        /* Device on auxiliary port 1 is not locked out. */
        Int_Lock_Aux_Port1();
        Set_Aux_Port1_Dat();       /* Reset data transmission line. */
    }

    #if AUX_PORT2_SUPPORTED
    if (Aux_Port2.lock == 0)
    {
        /* Device on auxiliary port 2 is not locked out. */
        Int_Lock_Aux_Port2();
        Set_Aux_Port2_Dat();       /* Reset data transmission line. */
    }
    #endif

    #if AUX_PORT3_SUPPORTED
    if (Aux_Port3.lock == 0)
    {
        /* Device on auxiliary port 3 is not locked out. */
        Int_Lock_Aux_Port3();
        Set_Aux_Port3_Dat();       /* Reset data transmission line. */
    }
    #endif

    /*
    Assume that at least one device was not
    locked out and start inhibit delay timer. */

    Load_Timer_B();
    Timer_B.bit.INH_CLEAR = 1;
}
#endif // !TICKER_1MS


/* ---------------------------------------------------------------
   Name: Irq_Anykey

   Any key press interrupt handler.  Disable further
   key interrupts and post key service request.

   Specials: All registers that are used
             must be preserved for IRQ handlers!
   --------------------------------------------------------------- */
void Irq_Anykey(void)
{
   /* Clear pending input sources used by scanner. */
   WKPCL3 = Msk_Scan_In;
   ICU_Clr_Pending_Irq(ICU_EINT_KBD_SCAN);
   if (Int_Var.Low_Power_Mode == 0)
   {
      /* Not recovery from low power mode.  Normal wakeup from regular idle
         mode because a key was pressed on internal keyboard (scanner). */

      Disable_Any_Key_Irq();  /* Disable any key interrupt. */
      Service.bit.KEY = 1;    /* Post service request to
                                 scan internal keyboard. */

      Enable_Timer_A();

   }
   else
   {
      /* Recovery from low power mode.

         This must be a valid wakeup interrupt because
         only valid wakeup interrupts are enabled.  */

      Int_Var.Low_Power_Mode = 0;/* Clear Low_Power_Mode flag to
                                    notify IDLE loop of recovery. */

      /* --------- Wait for wakeup key release. --------- */

      /* Read_Scan_Lines returns the key sense lines that
         are enabled.  The lines that are not enabled return 1s. */

      while (KBSIN != 0xFF);
      if ((KBSIN != 0xFF) && !Timer_A.bit.TMR_SCAN)
      {
         Service.bit.KEY = 1;    /* Post service request to
                                   scan internal keyboard. */
      }
      Disable_Any_Key_Wakeup();  /* Disable any key wakeup feature. */
   }


    #if HW_KB_SCN_SUPPORTED
    // clear (W1C) KBSDONE bit
    SET_BIT(KBSEVT, KBSDONE);

    // trigger the first scan
    SET_BIT(KBSCTL, KBSSTART);
    #endif // HW_KB_SCN_SUPPORTED

}

/* ---------------------------------------------------------------
   Name: Irq_Shm


   --------------------------------------------------------------- */
void Irq_Shm(void)
{
    if(IS_BIT_SET(SMC_STS, HSEM2W)) // STS_HSEM2W bit
    {
        CLEAR_BIT(SMC_CTRL, HSEM2_IE); // HSEM2_IE bit
        Service.bit.UPD_FLASH = 1;
    }
}

void Irq_Obe1(void)
{
    Disable_Host_OBE1_Irq();
    Timer_B.bit.INH_CLEAR = 0; /* Always clear inhibit. */
    Timer_B.bit.UNLOCK_TMO = 1;
    Load_Timer_B();
}